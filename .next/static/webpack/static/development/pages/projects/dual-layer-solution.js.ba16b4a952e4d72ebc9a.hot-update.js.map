{"version":3,"file":"static/webpack/static/development/pages/projects/dual-layer-solution.js.ba16b4a952e4d72ebc9a.hot-update.js","sources":["webpack:///./components/Projects/AutoBackGroundColorSliderPage/index.tsx","webpack:///./utils/rgbaster/helper.ts","webpack:///./utils/rgbaster/index.ts"],"sourcesContent":["import React, { FC, useRef, useState } from 'react';\nimport { useComponentDidMount } from '../../../utils/hooks/useComponentDidMount';\n// @ts-ignore\nimport findMainThemeWorker from 'worker-loader?name=static/[hash].worker.js!../../../utils/workers/findMainTheme.worker';\nimport analyze from '../../../utils/rgbaster';\nimport { css } from 'next/dist/build/webpack/config/blocks/css';\n\ninterface IProps {\n  src: string;\n  alt: string;\n}\n\nconst AutoBackGroundColorSliderPage: FC<IProps> = (props: IProps) => {\n  const { src, alt } = props;\n  const [backgroundColor, setBackGroundColor] = useState('#ffffff');\n  useComponentDidMount(() => {\n    const img = new Image();\n    img.src = src;\n    img.onload = () => {\n      console.log(findMainThemeWorker);\n      const worker = new findMainThemeWorker();\n      worker.postMessage('Hi! From Host');\n      worker.onmessage = e => {\n        console.log(e);\n        console.log(JSON.stringify(e));\n      };\n      analyze(src, img)\n        // analyze(src)\n        .then(value => {\n          console.log(value);\n          if (value[0]) {\n            setBackGroundColor(value[0].color);\n          }\n        })\n        .catch(err => console.log(err));\n    };\n  });\n  return (\n    <div\n      className={'section'}\n      style={{\n        backgroundColor: backgroundColor\n      }}\n    >\n      <img src={src} alt={alt} />\n    </div>\n  );\n};\n\nexport default AutoBackGroundColorSliderPage;\n","export const getContext = (width, height) => {\n  const canvas = document.createElement('canvas');\n  canvas.setAttribute('width', width);\n  canvas.setAttribute('height', height);\n  return canvas.getContext('2d');\n};\n\nexport const getImageData = (\n  src: string,\n  img: HTMLImageElement,\n  scale: number = 1\n): Promise<Uint8ClampedArray> => {\n  return new Promise((resolve, reject) => {\n    img.onload = function() {\n      const width = img.width * scale;\n      const height = img.height * scale;\n      const context = getContext(width, height);\n      context.drawImage(img, 0, 0, width, height);\n\n      const { data } = context.getImageData(0, 0, width, height);\n      resolve(data);\n    };\n\n    const errorHandler = () =>\n      reject(new Error('An error occurred attempting to load image'));\n\n    img.onerror = errorHandler;\n    img.onabort = errorHandler;\n    img.src = src;\n  });\n};\n\nexport const getCounts = (data: Uint8ClampedArray, ignore: string[]): [] => {\n  const countMap = {};\n\n  for (let i = 0; i < data.length; i += 4 /* 4 gives us r, g, b, and a*/) {\n    let alpha: number = data[i + 3];\n    // skip FULLY transparent pixels\n    if (alpha === 0) continue;\n\n    let rgbComponents: number[] = Array.from(data.subarray(i, i + 3));\n\n    // skip undefined data\n    if (rgbComponents.indexOf(undefined) !== -1) continue;\n\n    let color: string =\n      alpha && alpha !== 255\n        ? `rgba(${[...rgbComponents, alpha].join(',')})`\n        : `rgb(${rgbComponents.join(',')})`;\n\n    // skip colors in the ignore list\n    if (ignore.indexOf(color) !== -1) continue;\n\n    if (countMap[color]) {\n      countMap[color].count++;\n    } else {\n      countMap[color] = { color, count: 1 };\n    }\n  }\n\n  const counts = Object.values(countMap) as [];\n  return counts.sort((a: any, b: any) => b.count - a.count);\n};\n","import { getImageData, getCounts } from './helper';\n\ninterface Opts {\n  ignore?: string[];\n  scale?: number;\n  skipTransparentPixels?: boolean;\n}\n\nconst defaultOpts: Opts = {\n  ignore: [],\n  scale: 1\n};\n\nexport default async function(\n  src: string,\n  img: HTMLImageElement,\n  opts: Opts = defaultOpts\n): Promise<{ color: string; count: number }[]> {\n  opts = { ...defaultOpts, ...opts };\n\n  const {\n    ignore, // for example, to ignore white and black:  [ 'rgb(0,0,0)', 'rgb(255,255,255)' ]\n    scale // 0 = best performance, lowest fidelity\n    // 1 = best fidelity, worst performance\n  } = opts;\n\n  if (scale > 1 || scale <= 0) {\n    console.warn(\n      `You set scale to ${scale}, which isn't between 0-1. This is either pointless (> 1) or a no-op (â‰¤ 0)`\n    );\n  }\n\n  const data = await getImageData(src, img, scale);\n  return getCounts(data, ignore);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9DA;AAQA;AACA;AACA;AAFA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAGA;AAEA;AALA;AACA;AAYA;AACA;AAGA;AACA;AAlBA;AAAA;AACA;AADA;AAmBA;AAnBA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;A","sourceRoot":""}