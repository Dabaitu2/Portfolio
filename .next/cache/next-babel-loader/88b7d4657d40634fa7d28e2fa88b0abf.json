{"ast":null,"code":"export const getContext = (width, height) => {\n  const canvas = document.createElement('canvas');\n  canvas.setAttribute('width', width);\n  canvas.setAttribute('height', height);\n  return canvas.getContext('2d');\n};\nexport const getImageData = (src, scale = 1) => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n\n    img.onload = function () {\n      const width = img.width * scale;\n      const height = img.height * scale;\n      const context = getContext(width, height);\n      context.drawImage(img, 0, 0, width, height);\n      const {\n        data\n      } = context.getImageData(0, 0, width, height);\n      resolve(data);\n    };\n\n    const errorHandler = () => reject(new Error('An error occurred attempting to load image'));\n\n    img.onerror = errorHandler;\n    img.onabort = errorHandler;\n    img.src = src;\n  });\n};\nexport const getCounts = (data, ignore) => {\n  const countMap = {};\n\n  for (let i = 0; i < data.length; i += 4\n  /* 4 gives us r, g, b, and a*/\n  ) {\n    let alpha = data[i + 3]; // skip FULLY transparent pixels\n\n    if (alpha === 0) continue;\n    let rgbComponents = Array.from(data.subarray(i, i + 3)); // skip undefined data\n\n    if (rgbComponents.indexOf(undefined) !== -1) continue;\n    let color = alpha && alpha !== 255 ? `rgba(${[...rgbComponents, alpha].join(',')})` : `rgb(${rgbComponents.join(',')})`; // skip colors in the ignore list\n\n    if (ignore.indexOf(color) !== -1) continue;\n\n    if (countMap[color]) {\n      countMap[color].count++;\n    } else {\n      countMap[color] = {\n        color,\n        count: 1\n      };\n    }\n  }\n\n  const counts = Object.values(countMap);\n  return counts.sort((a, b) => b.count - a.count);\n};","map":{"version":3,"sources":["/Users/tomokokawase/Desktop/Portfolio/utils/rgbaster/helper.ts"],"names":["getContext","width","height","canvas","document","createElement","setAttribute","getImageData","src","scale","Promise","resolve","reject","img","Image","onload","context","drawImage","data","errorHandler","Error","onerror","onabort","getCounts","ignore","countMap","i","length","alpha","rgbComponents","Array","from","subarray","indexOf","undefined","color","join","count","counts","Object","values","sort","a","b"],"mappings":"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","sourcesContent":["export const getContext = (width, height) => {\n  const canvas = document.createElement('canvas');\n  canvas.setAttribute('width', width);\n  canvas.setAttribute('height', height);\n  return canvas.getContext('2d');\n};\n\nexport const getImageData = (\n  src: string,\n  scale: number = 1\n): Promise<Uint8ClampedArray> => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = function() {\n      const width = img.width * scale;\n      const height = img.height * scale;\n      const context = getContext(width, height);\n      context.drawImage(img, 0, 0, width, height);\n\n      const { data } = context.getImageData(0, 0, width, height);\n      resolve(data);\n    };\n\n    const errorHandler = () =>\n      reject(new Error('An error occurred attempting to load image'));\n\n    img.onerror = errorHandler;\n    img.onabort = errorHandler;\n    img.src = src;\n  });\n};\n\nexport const getCounts = (data: Uint8ClampedArray, ignore: string[]): [] => {\n  const countMap = {};\n\n  for (let i = 0; i < data.length; i += 4 /* 4 gives us r, g, b, and a*/) {\n    let alpha: number = data[i + 3];\n    // skip FULLY transparent pixels\n    if (alpha === 0) continue;\n\n    let rgbComponents: number[] = Array.from(data.subarray(i, i + 3));\n\n    // skip undefined data\n    if (rgbComponents.indexOf(undefined) !== -1) continue;\n\n    let color: string =\n      alpha && alpha !== 255\n        ? `rgba(${[...rgbComponents, alpha].join(',')})`\n        : `rgb(${rgbComponents.join(',')})`;\n\n    // skip colors in the ignore list\n    if (ignore.indexOf(color) !== -1) continue;\n\n    if (countMap[color]) {\n      countMap[color].count++;\n    } else {\n      countMap[color] = { color, count: 1 };\n    }\n  }\n\n  const counts = Object.values(countMap) as [];\n  return counts.sort((a: any, b: any) => b.count - a.count);\n};\n"]},"metadata":{},"sourceType":"module"}